# Need to figure out how to deal with user inputs but we'll assume they are taking up the first 
# 23 spaces of memory after 0x0000: (T (0x0001 or 1), best_matching_score (0x0002 or 2), best_matching_count (0x0003 or 3),
# Pattern_Array (0x0004 - 0x0018 or 4-24)


#Initialize best_matching_score and best_matching_count to -1 as initialization each:
init $r0, -1 # set r0 = -1
init $r1, 1 # set r1 = 1
add $r1, $r1 # r1 = 1 + 1 = 2
sw $r0, $r1 # set $r0 val of -1 into mem loc 2 which is 0x0002
init $r0, 1 # set r0 = 1 temporarily
add $r1, $r0 # r1 = 2 + 1 = 3
init $r0, -1 # set r0 back to -1
sw $r0, $r1 # set $r0 val of -1 into mem loc 3 which is 0x0003
init $r0, 0 # reset r0 back to 0
init $r1, 0 # reset r1 back to 0

#Storing 20 in memory. This will help for our array loop
addi $r2, 1 # registers are initially at 0, so r2 = 0 + 1 = 1
sll $r2, 3 # r2 = r2 << 3 = 8
sll $r2, 1 # r2 = r2 << 1 = 16
addi $r2, 3 # r2 = 16 + 3 = 19
addi $r2, 1 # r2 = 19 + 1 = 20
addi $r3, 3 # r3 = 0 + 3 = 3
addi $r3, 1 # r3 = 3 + 1 = 4
add $r0, $r2 # r0 = 0 + 20 = 20
add $r0, $r3 # r0 = 20 + 4 = 24, this is for the mem loc 
sw $r2, $r0 # store $r2 val of 20 into mem loc 24 which is 0x0018
#At this point, $r3 = 4, $r2 = 20 and $r0 = 24

#Storing 32 in memory for calculating HD later
addi $r2, 3 # r2 = 20 + 3 = 23
addi $r2, 2 # r2 = 23 + 2 = 25
sll $r3, 1 # r3 = 4 << 1 = 8
add $r0, $r3 # r0 = 24 + 8 = 32
sw $r0, $r2 # store $r0 val of 32 into mem loc 25 which is 0x0019
#At this point, $r3 = 8, $r2 = 25, $r0 = 32

#Set r0 = 20 and r1 = 0 for array loop initialization:
#r0 = 20:
sub $r0, $r3 # r0 = 32 - 8 = 24
subi $r3, 3 # r3 = 8 - 3 = 5
subi $r3, 1 # r3 = 5 - 1 = 4
sub $r0, $r3 # r0 = 24 - 4 = 20
# $r1 is already = 0 at this point
#At this point, $r3 = 4, $r2 = 25, $r1 = 0, $r0 = 20

a_loop: # array loop
	beqR0 out #IMPORTANT: using branch 'out' instead of imm val for now

# The program, at the moment, is incomplete. Noticed insufficiency with register use and
# it would require a tweak in the ISA Design. Will discuss in next meeting.